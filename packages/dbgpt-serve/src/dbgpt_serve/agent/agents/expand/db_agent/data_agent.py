"""Auto reasoning_engine chat manager agent."""

import json
import logging
import uuid
from typing import Dict, List, Optional, Tuple

from dbgpt.agent import (
    ActionOutput,
    ActorProxyAgent,
    Agent,
    AgentMessage,
    ConversableAgent,
    ProfileConfig,
)
from dbgpt.agent.core.base_team import ManagerAgent
from dbgpt.agent.core.memory.gpts import GptsPlan
from dbgpt.agent.core.schema import Status
from dbgpt.util.configure import DynConfig

from ..actions.planning_action import TaskPlan
from .knowledge_agent import KnowledgeAgent

logger = logging.getLogger(__name__)


class DBAnalyzerManager(ManagerAgent):
    """A chat manager agent that can manage a team chat of multiple agents."""

    profile: ProfileConfig = ProfileConfig(
        name=DynConfig(
            "AI-Analyzer(dbgpt)",
            category="agent",
            key="dbgpt_agent_team_sre_profile_name",
        ),
        role=DynConfig(
            "AI-Analyzer(dbgpt)",
            category="agent",
            key="dbgpt_agent_team_sre_profile_role",
        ),
        goal=DynConfig(
            "Advance the task reasoning_engine generated by the planning agent. If the reasoning_engine "
            "does not pre-allocate an agent, it needs to be coordinated with the "
            "appropriate agent to complete.",
            category="agent",
            key="dbgpt_agent_team_sre_profile_goal",
        ),
        desc=DynConfig(
            "Advance the task reasoning_engine generated by the planning agent.",
            category="agent",
            key="dbgpt_agent_team_sre_profile_desc",
        ),
        avatar="dbgpt.jpg",
    )
    concurrency_limit: int = 6
    # 当前Agent消息是否显示
    show_message: bool = False
    current_goal: str = None

    def __init__(self, **kwargs):
        """Create a new AutoPlanChatManager instance."""
        super().__init__(**kwargs)

    async def act(
        self,
        message: Optional[AgentMessage],
        sender: Optional[ActorProxyAgent] = None,
        reviewer: Optional[ActorProxyAgent] = None,
        **kwargs,
    ) -> Optional[ActionOutput]:
        """Perform an action based on the received message."""
        if not sender:
            return ActionOutput(
                is_exe_success=False,
                content="The sender cannot be empty!",
            )

        try:
            all_task_messages: List = []
            all_messages: List = []
            ## 绑定Agent处理，和解决内外置规划、总结Agent逻辑
            from dbgpt.agent.expand.summary_assistant_agent import SummaryAssistantAgent

            from .planning_agent import PlanningAgent

            ### 处理绑定的Agent 如果没有规划和总结，构建默认规划总结Agent， 如果有绑定使用绑定的，如果绑定多个使用最后一个
            valid_agents: List[ConversableAgent] = []
            from dbgpt_serve.agent.agents.expand.db_agent.dashboard_agent import (
                ReportAssistantAgent,
            )

            reporter: Optional[ReportAssistantAgent] = None
            planner: Optional[PlanningAgent] = None
            for agent in self.agents:
                if isinstance(agent, ReportAssistantAgent):
                    reporter = agent
                elif isinstance(agent, PlanningAgent):
                    planner = agent
                else:
                    valid_agents.append(agent)

            if not reporter:
                reporter = (
                    await ReportAssistantAgent()
                    .bind(self.memory)
                    .bind(self.agent_context)
                    .bind(self.llm_config)
                    .build()
                )
            valid_agents.append(reporter)

            if not planner:
                planner = (
                    await PlanningAgent()
                    .bind(self.memory)
                    .bind(self.agent_context)
                    .bind(self.llm_config)
                    .build()
                )
            planner.hire(valid_agents)

            ## 处理后的所有有效Agent
            self.agents = valid_agents
            logger.info(f"all valid agents:{[item.name for item in valid_agents]}")

            plan_round_count = message.rounds
            for i in range(self.max_round):
                if not self.memory:
                    return ActionOutput(
                        is_exe_success=False,
                        content="The memory cannot be empty!",
                    )

                ## 读取历史消息进展
                plan_in_rounds = plan_round_count * self.max_round
                ## 规划新的任务步骤
                if i <= 0:
                    plan_in_message = AgentMessage.init_new(
                        content=message.content,
                        rounds=plan_in_rounds,
                        current_goal=f"Round {i + 1} - {planner.current_goal}",
                    )
                else:
                    plan_in_message = AgentMessage.init_new(
                        content=f"继续根据给定的规则对目标问题进行推理:\n\n{message.content}\n\n",
                        rounds=plan_in_rounds,
                        current_goal=f"Round {i + 1} - {planner.current_goal}",
                    )
                plan_round_count = plan_round_count + 1
                await self.send(
                    message=plan_in_message, recipient=planner, request_reply=False
                )

                plan_message = await planner.generate_reply(
                    received_message=plan_in_message,
                    sender=self,
                    reviewer=reviewer,
                    historical_dialogues=sorted(
                        all_task_messages, key=lambda obj: obj.rounds
                    ),
                    force_use_historical=True,
                )

                all_messages.append(plan_in_message)
                await planner.send(
                    message=plan_message, recipient=self, request_reply=False
                )

                all_messages.append(plan_message)
                if plan_message.action_report.is_exe_success:
                    task_list = json.loads(plan_message.action_report.content)
                    task_params: List[TaskPlan] = [
                        TaskPlan(**item) for item in task_list
                    ]
                else:
                    continue

                ## 执行新的任务步骤(排除需要用户代理处理的任务)
                api_tasks = []
                from dbgpt.agent import get_agent_manager

                ask_user = None
                agent_role_map = {agent.name: agent for agent in self.agents}
                task_map = {}

                ## 考虑重试，分支等逻辑，给每个子Agent分配一个百位段的 round区间（可根据最大轮次动态配置）
                task_round_count = 1
                task_max_round = 10

                reporter_agent = None
                reporter_in_message = None

                for task in task_params:
                    agent_goal_id = task.task_id
                    agent_name = task.agent
                    agent_goal = task.instruction

                    plan: GptsPlan = GptsPlan(
                        conv_id=self.agent_context.conv_id,
                        conv_session_id=self.agent_context.conv_session_id,
                        conv_round=0,
                        sub_task_id=agent_goal_id,
                        sub_task_num=0,
                        task_uid=uuid.uuid4().hex,
                        sub_task_content=agent_goal,
                        sub_task_title=task.task_step,
                        sub_task_agent=agent_name,
                        state=Status.TODO.value,
                    )
                    await self.memory.gpts_memory.append_plans(
                        conv_id=self.agent_context.conv_id, plans=[plan]
                    )

                    task_round_init = task_round_count * task_max_round
                    if agent_name == "Human":
                        ask_user = agent_goal
                        continue
                    if not agent_name:
                        raise ValueError(
                            f"have not found available agent[{agent_name}]!"
                        )

                    task_agent: ConversableAgent = agent_role_map.get(agent_name)
                    if not task_agent:
                        logger.warning(f"agent{agent_name}have not found!")
                        continue
                    agent_role_map.update({task_agent.name: task_agent})

                    task_in_message = AgentMessage.init_new(
                        content=f"{agent_goal}",
                        current_goal=agent_goal,
                        goal_id=agent_goal_id,
                        rounds=plan_in_rounds + task_round_init,
                    )

                    plan.state = Status.RUNNING.value
                    await self.memory.gpts_memory.update_plan(
                        self.agent_context.conv_id, plan
                    )

                    task_map[task.agent] = plan
                    if task_agent.name == reporter.name:
                        reporter_agent = task_agent
                        task_in_message.current_goal = self.current_goal
                        reporter_in_message = task_in_message
                    else:
                        # task_agent.stream_out = False
                        task_round_count = task_round_count + 1
                        api_tasks.append(
                            task_agent.generate_reply(
                                received_message=task_in_message,
                                sender=self,
                                reviewer=reviewer,
                            )
                        )

                        await self.send(
                            message=task_in_message,
                            recipient=task_agent,
                            request_reply=False,
                        )

                        all_task_messages.append(task_in_message)
                        all_messages.append(task_in_message)

                if reporter_agent:
                    api_tasks.append(
                        reporter_agent.generate_reply(
                            received_message=reporter_in_message,
                            sender=self,
                            reviewer=reviewer,
                            rely_messages=None,  # 会变成单轮消息
                            historical_dialogues=sorted(
                                all_task_messages, key=lambda obj: obj.rounds
                            ),  # 会变成多轮历史消息
                            force_use_historical=True,
                        )
                    )

                from dbgpt.util.chat_util import run_async_tasks

                results: List[AgentMessage] = await run_async_tasks(
                    tasks=api_tasks, concurrency_limit=self.concurrency_limit
                )

                ## 检察所有计划任务输出，有效输出记录消息
                for result in results:
                    task_agent = agent_role_map.get(result.name)
                    plan = task_map.get(result.name)
                    if result.action_report.is_exe_success:
                        plan.state = Status.COMPLETE.value
                    else:
                        plan.state = Status.FAILED.value
                    await self.memory.gpts_memory.update_plan(
                        self.agent_context.conv_id, plan
                    )

                    if result.name == reporter.name:
                        logger.info(f"reporter result:{result.action_report}")

                        if task_agent:
                            await task_agent.send(
                                message=result, recipient=self, request_reply=False
                            )
                        self.current_goal = reporter.current_goal
                        return ActionOutput(
                            is_exe_success=True, content="Data Analysis Success!"
                        )
                    else:
                        ## 如果没有用户任务，重新进入下一个阶段直到出现终止任务的Agent
                        logger.info(f"消息发送给:{task_agent},{result.name},{result}")
                        if task_agent:
                            await task_agent.send(
                                message=result, recipient=self, request_reply=False
                            )
                            all_task_messages.append(result)
                            all_messages.append(result)

                ## 处理用户代理任务，终断循环，进入用户交互
                if ask_user:
                    return ActionOutput(is_exe_success=True, content=ask_user)
        except Exception as e:
            logger.exception("ReAct Team Chat Exception！")
            return ActionOutput(is_exe_success=False, content=str(e))

    async def thinking(
        self,
        messages: List[AgentMessage],
        reply_message_id: str,
        reply_message: AgentMessage,
        sender: Optional[ActorProxyAgent] = None,
        prompt: Optional[str] = None,
        current_goal: Optional[str] = None,
    ) -> Tuple[Optional[str], Optional[str], Optional[str]]:
        """Think and reason about the current task goal."""
        # TeamManager, which is based on processes and plans by default, only needs to
        # ensure execution and does not require additional thinking.
        if messages is None or len(messages) <= 0:
            return None, None, None
        else:
            message = messages[-1]
            self.messages.append(message.to_llm_message())
            return message.thinking, message.content, None
