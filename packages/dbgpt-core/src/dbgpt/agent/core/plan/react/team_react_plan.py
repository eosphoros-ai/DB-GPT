"""Auto reasoning_engine chat manager agent."""

import json
import logging
from typing import Dict, List, Optional, Tuple

from dbgpt._private.pydantic import (
    Field,
    model_to_dict,
)
from dbgpt.core import ModelMessageRoleType
from dbgpt.util.configure import DynConfig

from ...base_agent import (
    ActionOutput,
    Agent,
    AgentMessage,
    ConversableAgent,
    ProfileConfig,
)
from ...base_team import ManagerAgent
from ...memory.gpts import GptsPlan
from ..base import TeamContext
from .final_report_agent import FinalReportAssistantAgent
from .planner_agent import ReActPlannerAgent

logger = logging.getLogger(__name__)


class AutoTeamContext(TeamContext):
    teamleader: Optional[str] = Field(
        None,
        description="The multi agents teamleader",
        examples=[
            "advance_planning",
            "dynamic_planning",
        ],
    )

    def to_dict(self):
        return model_to_dict(self)


class ReActPlanChatManager(ManagerAgent):
    """A chat manager agent that can manage a team chat of multiple agents."""

    profile: ProfileConfig = ProfileConfig(
        name=DynConfig(
            "ReAct Manager",
            category="agent",
            key="dbgpt_agent_plan_team_react_plan_profile_name",
        ),
        role=DynConfig(
            "ReActManager",
            category="agent",
            key="dbgpt_agent_plan_team_react_plan_profile_role",
        ),
        goal=DynConfig(
            "Advance the task reasoning_engine generated by the planning agent."
            " If the reasoning_engine "
            "does not pre-allocate an agent, it needs to be coordinated with the "
            "appropriate agent to complete.",
            category="agent",
            key="dbgpt_agent_plan_team_auto_plan_profile_goal",
        ),
        desc=DynConfig(
            "Advance the task reasoning_engine generated by the planning agent.",
            category="agent",
            key="dbgpt_agent_plan_team_auto_plan_profile_desc",
        ),
    )
    concurrency_limit: int = 6
    # 当前Agent消息是否显示
    show_message: bool = False

    def __init__(self, **kwargs):
        """Create a new AutoPlanChatManager instance."""
        super().__init__(**kwargs)

    async def process_rely_message(
        self, conv_id: str, now_plan: GptsPlan, speaker: Agent
    ):
        """Process the dependent message."""
        rely_prompt = None
        rely_messages: List[Dict] = []

        if now_plan.rely and len(now_plan.rely) > 0:
            rely_tasks_list = now_plan.rely.split(",")
            rely_tasks_list_int = [int(i) for i in rely_tasks_list]
            rely_tasks = self.memory.plans_memory.get_by_conv_id_and_num(
                conv_id, rely_tasks_list_int
            )
            if rely_tasks:
                rely_prompt = (
                    "Read the result data of the dependent steps in the above"
                    " historical message to complete the current goal:"
                )
                for rely_task in rely_tasks:
                    rely_messages.append(
                        {
                            "content": rely_task.sub_task_content,
                            "role": ModelMessageRoleType.HUMAN,
                            "name": rely_task.sub_task_agent,
                        }
                    )
                    rely_messages.append(
                        {
                            "content": rely_task.result,
                            "role": ModelMessageRoleType.AI,
                            "name": rely_task.sub_task_agent,
                        }
                    )
        return rely_prompt, rely_messages

    async def act(
        self,
        message: Optional[AgentMessage],
        sender: Optional[Agent] = None,
        reviewer: Optional[Agent] = None,
        **kwargs,
    ) -> Optional[ActionOutput]:
        """Perform an action based on the received message."""
        if not sender:
            return ActionOutput(
                is_exe_success=False,
                content="The sender cannot be empty!",
            )

        try:
            message_rounds = message.rounds
            last_round_messages: List = []
            all_task_messages: List = []
            all_messages: List = []

            for i in range(self.max_round):
                if not self.memory:
                    return ActionOutput(
                        is_exe_success=False,
                        content="The memory cannot be empty!",
                    )

                ## 读取新的背景知识

                ## 读取历史消息进展

                ## 内置报告Agent TODO 考虑外部绑定
                final_reporter: ConversableAgent = (
                    await FinalReportAssistantAgent()
                    .bind(self.memory)
                    .bind(self.agent_context)
                    .bind(self.llm_config)
                    .build()
                )
                self.agents.append(final_reporter)
                ## 规划新的任务步骤
                planner: ConversableAgent = (
                    await ReActPlannerAgent()
                    .bind(self.memory)
                    .bind(self.agent_context)
                    .bind(self.bind_prompt)
                    .bind(self.llm_config)
                    .bind_agents(self.agents)
                    .build()
                )

                last_round_messages.clear()

                plan_in_message = AgentMessage.init_new(
                    content=message.content, rounds=message_rounds
                )

                await self.send(
                    message=plan_in_message, recipient=planner, request_reply=False
                )

                plan_message = await planner.generate_reply(
                    received_message=plan_in_message,
                    sender=self,
                    reviewer=reviewer,
                    historical_dialogues=all_messages,
                    force_use_historical=True,
                )

                last_round_messages.append(plan_in_message)
                all_messages.append(plan_in_message)
                await planner.send(
                    message=plan_message, recipient=self, request_reply=False
                )
                message_rounds = plan_message.rounds

                last_round_messages.append(plan_message)
                all_messages.append(plan_message)
                if plan_message.action_report.is_exe_success:
                    task_params = json.loads(plan_message.action_report.content)
                else:
                    continue

                ## 执行新的任务步骤(排除需要用户代理处理的任务)
                api_tasks = []

                ask_user = None
                agent_role_map = {agent.name: agent for agent in self.agents}
                task_in_message_map = {}
                for task in task_params:
                    agent_name = task.get("agent")
                    agent_goal = task.get("task_goal")
                    agent_goal_id = task.get("task_id")
                    if agent_name == "Human":
                        ask_user = agent_goal
                        continue

                    if not agent_name:
                        raise

                    task_agent: ConversableAgent = agent_role_map.get(agent_name)
                    if not task_agent:
                        logger.warning(f"agent{agent_name}没有找到具体agent！")
                        continue
                    agent_role_map.update({task_agent.name: task_agent})

                    task_in_message = AgentMessage.init_new(
                        content=f"任务目标:{agent_goal},相关参数:{json.dumps(task.get('slots'))}",
                        current_goal=agent_goal,
                        goal_id=agent_goal_id,
                        rounds=message_rounds,
                    )
                    message_rounds = task_in_message.rounds + 1

                    task_in_message_map.update({agent_name: task_in_message})
                    if task_agent.name == "final_report_agent":
                        api_tasks.append(
                            task_agent.generate_reply(
                                received_message=task_in_message,
                                sender=self,
                                reviewer=reviewer,
                                rely_messages=None,  # 会变成单论消息
                                # 会变成多轮历史消息
                                historical_dialogues=all_task_messages,
                            )
                        )

                    else:
                        task_agent.stream_out = False
                        api_tasks.append(
                            task_agent.generate_reply(
                                received_message=task_in_message,
                                sender=self,
                                reviewer=reviewer,
                            )
                        )

                from dbgpt.util.chat_util import run_async_tasks

                results: List[AgentMessage] = await run_async_tasks(
                    tasks=api_tasks, concurrency_limit=self.concurrency_limit
                )

                ## 检察所有计划任务输出，有效输出记录消息
                for result in results:
                    task_agent = agent_role_map.get(result.name)
                    ## 判断消息结果
                    if result.name == "final_report_agent":
                        ## 处理终止代理任务，结束对话，告诉用户结论
                        return result.action_report
                    else:
                        ## 如果没有用户任务，重新进入下一个阶段直到出现终止任务的Agent

                        task_in_message = task_in_message_map.get(result.name)
                        logger.info(f"消息发送给:{task_agent},{result.name},{result}")
                        if task_agent:
                            await self.send(
                                message=task_in_message,
                                recipient=task_agent,
                                request_reply=False,
                            )
                            last_round_messages.append(task_in_message)
                            all_task_messages.append(task_in_message)
                            all_messages.append(task_in_message)
                            await task_agent.send(
                                message=result, recipient=self, request_reply=False
                            )
                            all_task_messages.append(result)
                            last_round_messages.append(result)
                            all_messages.append(result)

                ## 处理用户代理任务，终断循环，进入用户交互
                if ask_user:
                    return ActionOutput(is_exe_success=True, content=ask_user)
        except Exception as e:
            logger.exception("ReAct Team Chat Exception！")
            return ActionOutput(is_exe_success=False, content=str(e))

    async def thinking(
        self,
        messages: List[AgentMessage],
        reply_message_id: str,
        sender: Optional[Agent] = None,
        prompt: Optional[str] = None,
    ) -> Tuple[Optional[str], Optional[str], Optional[str]]:
        """Think and reason about the current task goal."""
        # TeamManager, which is based on processes and plans by default, only needs to
        # ensure execution and does not require additional thinking.
        if messages is None or len(messages) <= 0:
            return None, None, None
        else:
            message = messages[-1]
            self.messages.append(message.to_llm_message())
            return message.thinking, message.content, None
